==================
The Shapely Manual
==================

:Author: Sean Gillies
:address: sean.gillies@gmail.com
:revision: 1.2
:date: 1 March 2010
:copyright: This work is licensed under a `Creative Commons Attribution 3.0
  United States License`__.

.. __: http://creativecommons.org/licenses/by/3.0/us/

:abstract: This document describes the Shapely Python package for programming
  with planar geometries.

.. sectnum::

.. contents::


Introduction
============

Shapely is a Python package for manipulating and analyzing planar geometries
using (via Python's `ctypes` module) functions from the well known and widely
deployed GEOS_ library. GEOS, a port of the `Java Topology Suite`_, is the
geometry engine of the PostGIS_ spatial extension for the PostgreSQL RDBMS.
PostGIS is one of the cornerstones of open source GIS, but isn't a solution to
all problems in the GIS domain. Not all geographic data reside in a RDBMS or
are best processed using SQL. Shapely aims to bring industrial strength GIS
primitives to bear on programming problems better addressed in a
object-oriented style. 

Imagine a situation where you'd like to find or index a substring within
another string. Is there overlap between the strings, and if so, what is it?
Or maybe you'd like to replace certain characters in a string with others. Now
imagine that you're compelled to load the text strings into a relational
database to perform these operations because such string functions aren't
available in any other context. No knock on the RDBMS, a tremendously useful
thing, but that's a unacceptable situation.

The premise of Shapely, or one of the premises, is that Python programmers
should be able to perform PostGIS type geometry operations outside of an RDBMS.
Another is that Python idioms trump GIS (or Java, in this case, since the GEOS
library is derived from JTS, a Java project) idioms. Shapely, in a nutshell
lets you do PostGIS-y stuff outside the context of a database using idiomatic
Python.

By "PostGIS-y" we mean to say: "implements much of the Open Geospatial
Consortium's Simple Feature Access specification [1]". Standard geometry types
are implemented as Python classes and standard operations are implemented as
properties or methods of those classes. Focussing strictly on planar geometry,
Shapely isn't concerned with coordinate systems or other aspects of the
standard GIS feature model, but neither does it stand in the way of
applications where those concerns are important. Shapely has been designed to
be less specific to the GIS domain to improve its potential for reuse in other
applications such as games, image analysis, and even genomics.


Geometries
==========

The standard GIS geometry model consists of single points, line strings (or
polylines), polygons, homogeneous multi-point, multi-line string, and
multi-polygon collections, and heterogeneous geometry collections. These types
are illustrated below.

.. container:: figures

  .. figure:: jts-point.png
  
     Point
  
  .. figure:: jts-multipoint.png
  
     MultiPoint
  
  .. figure:: jts-linestring.png
  
     LineString
  
  .. figure:: jts-multilinestring.png
  
     MultiLineString
  
  .. figure:: jts-polygon.png
  
     Polygon
  
  .. figure:: jts-multipolygon.png
  
     MultiPolygon
  
  .. figure:: jts-geometrycollection.png
  
     GeometryCollection

.. container:: clear

   From: http://www.vividsolutions.com/jts/discussion.htm#spatialDataModel

Shapely 1.2 does not provide circles, spline curves, or their two dimensional
(patch-like) counterparts. Circular patches must be approximated by polygons.

Creating Geometries
-------------------

Geometries can be created in the typical Python fashion, using the geometry
classes themselves as factories. 

Point and LineString (and LinearRing) geometries have coordinate sequences.
Coordinate sequences are immutable. Geometries are mutable in that they can be
assigned new coordinate sequences.

A third `z` coordinate value may be used when constructing geometries, but it
has no effect on geometry analysis. All operations are performed in the x-y
plane.

Pseudo-code blocks in this section will use the following notation. Let **a**
be a Cartesian *x*, *y*, and optional *z* coordinate sequence. The coordinates
values must be numeric types. Let (**a**\ 1, ..., **a**\ M) and (**b**\ 1, ...,
**b**\ N) be ordered sequences of *M* and *N* such coordinate sequences,
defining lines or rings.

Numeric values passed to geometry factories are converted to type `float`.

Points
++++++

The point factory *Point* takes a coordinate sequence parameter

.. sourcecode:: python

  >>> from shapely.geometry import Point
  >>> point = Point(a)

The alternate form is to pass individual coordinate parameters

.. sourcecode:: python

  >>> point = Point(x0, y0 [, z0])

Example:

.. sourcecode:: python

  >>> print Point((0, 0))
  POINT (0.0000000000000000 0.0000000000000000)
  >>> print Point(0, 0)
  POINT (0.0000000000000000 0.0000000000000000)

LineStrings
+++++++++++

To create a line string, pass in an ordered sequence of coordinate sequences:

.. sourcecode:: python

  >>> from shapely.geometry import LineString
  >>> line = LineString((a1, ..., aM))

Example:

.. sourcecode:: python

  >>> print LineString([(0, 0), (1, 1)])
  LINESTRING (0.0000000000000000 0.0000000000000000, 1.0000000000000000 1.0000000000000000)


Polygons
++++++++

A polygon with only an exterior boundary and no holes is created by passing the sequence representation of a closed ring

.. sourcecode:: python

  >>> from shapely.geometry import Polygon
  >>> polygon = Polygon((a1, ..., aM))

If **a**\ 1 is not exactly equal to **a**\ M, the factory will close the ring.
The following (unit square) polygons are therefore topologically equal

.. sourcecode:: python

  >>> polygon1 = Polygon(((0, 0), (0, 1), (1, 1), (1, 0), (0, 0)))
  >>> polygon2 = Polygon(((0, 0), (0, 1), (1, 1), (1, 0)))
  
To create a polygon with interior boundaries pass a sequence of rings to the
second parameter (*holes*)

.. sourcecode:: python

  >>> polygon = Polygon((a1, ..., aM), [(b1, ..., bN), ...])

Rings *must* be non-crossing, ordered coordinate sequences. The order may be
clockwise or counter-clockwise. The resulting topology is independent of the
order.


Multipart Geometry Factories
----------------------------

MultiPoints
+++++++++++

An *N*\ -point geometry is created by passing an unordered sequence of
coordinate sequences [**c**\ 1, ..., **c**\ N]

.. sourcecode:: python

  >>> from shapely.geometry import MultiPoint
  >>> points = MultiPoint([c1, ..., cN])

MultiLineStrings
++++++++++++++++

A multi-line geometry is created by passing a sequence of representations of
lines

.. sourcecode:: python

  >>> from shapely.geometry import MultiLineString
  >>> lines = MultiLineString([(a1, ..., aM), (b1, ..., bN), ...])

MultiPolygons
+++++++++++++

A multi-polygon geometry is created by passing a sequence of exterior ring and
hole list tuples 

.. sourcecode:: python

  >>> from shapely.geometry import MultiPolygon
  >>> lines = MultiPolygon([((a1, ..., aM), [(b1, ..., bN), ...]), ...])

More explicit notation for the exterior and interior boundaries (or shells and
holes) makes usage more clear

.. sourcecode:: python

  >>> shell = (a1, ..., aM)
  >>> holes = [(b1, ..., bN), ...]
  >>> lines = MultiPolygon([(shell, holes), ...])


Null Geometries
---------------

Null geometries can be created by calling the factories with no arguments, but
almost nothing can be done with a null geometry.

.. sourcecode:: python

  >>> line_null = LineString()
  >>> line_null.length
  Traceback (most recent call last):
  ...
  ValueError: Null geometry supports no operations

The coordinates of a null geometry *can* be set (see Section 3), after which
the geometry is no longer null.

.. sourcecode:: python

  >>> l_null.coords = [(0, 0), (1, 1)]
  >>> print l_null.length
  1.414...


Constructive Spatial Analysis Methods
-------------------------------------

There are methods of geometry classes that also serve as factories for new
geometries. It is important to note that these are topological and not
point-wise operations, and therefore may produce results that are not what one
might expect from operations on Python sets.

See also the JTS |illustration2|_.

.. |illustration2| replace:: illustration
.. _illustration2: http://www.jump-project.org/project.php?PID=JTS&SID=OVER#spatialanalysismethods

Example Geometries
++++++++++++++++++

.. sourcecode:: python

  >>> polygon = Polygon(((-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0), (1.0, -1.0)))
  >>> point_r = Point(-1.5, 1.2)
  >>> point_g = Point(-1.0, 1.0)
  >>> point_b = Point(-0.5, 0.5)
  >>> line_r = LineString(((-0.5, 0.5), (0.5, 0.5)))
  >>> line_g = LineString(((1.0, -1.0), (1.8, 0.5)))
  >>> line_b = LineString(((-1.8, -1.2), (1.8, 0.5)))

Buffer
++++++

.buffer(width, quadsegs=16) : geometry
  Returns a buffer region having the given width and with a specified number of
  segments used to approximate curves.
  
The default result of buffering a point is an N-gon approximation of a circle:

.. sourcecode:: python

  >>> buffered = point_r.buffer(1.0)
  >>> buffered
  <shapely.geometry.polygon.Polygon object at ...>
  >>> buffered.length
  6.2806623139097271
  >>> buffered.area
  3.1365484905463727
  >>> len(buffered.exterior.coords)
  66

Simplify
++++++++

.simplify(width, tolerance, preserve_topology=True) : geometry
  
  Returns a simplified version of the given geometry. All vertices in the
  simplified geometry will be within the `tolerance` distance of the original
  geometry. By default a slower algorithm is used that preserves topology. If
  preserve topology is set to False the much quicker Douglas-Peucker algorithm
  is used, and invalid geometries may result.
  
.. sourcecode:: python

  >>> p = Point(0.0, 0.0)
  >>> x = p.buffer(1.0)
  >>> x.area
  3.1365484905459389
  >>> len(x.exterior.coords)
  66
  >>> s = x.simplify(0.05, preserve_topology=False)
  >>> s.area
  3.0614674589207187
  >>> len(s.exterior.coords)
  17

Boundary
++++++++

.boundary : geometry
  Returns a lower dimension geometry. The boundary of a polygon is a line, the
  boundary of a line is a collection of points. The boundary of a point is an
  empty (null) collection.

.. sourcecode:: python

  >>> polygon.boundary
  <shapely.geometry.linestring.LineString object at ...>
  >>> line_b.boundary
  <shapely.geometry.multipoint.MultiPoint object at ...>
  >>> point_r.boundary.is_empty
  True

Centroid
++++++++

.centroid : geometry
  Returns the centroid, or geometric center of the polygon.

.. sourcecode:: python

  >>> centroid_point = polygon.centroid
  >>> centroid_point.wkt
  'POINT (-0.0000000000000000 -0.0000000000000000)'

Convex Hull
+++++++++++

.convex_hull : geometry
  Imagine an elastic band stretched around the geometry: that's a convex hull,
  more or less.

For example, collect the three points into a multi-point geometry, and get the
triangular polygon that is their convex hull:

.. sourcecode:: python

  >>> multi_point = point_r.union(point_g)
  >>> multi_point = multi_point.union(point_b)
  >>> multi_point.convex_hull
  <shapely.geometry.polygon.Polygon object at ...>

Difference
++++++++++

.difference(other) : geometry
  Returns a geometry representing the points making up this geometry that do
  not make up *other*. Note that A.difference(B) is not necessarily equal to
  B.difference(A).

.. sourcecode:: python

  >>> hull = multi_point.convex_hull
  >>> polygon.difference(hull)
  <shapely.geometry.polygon.Polygon object at ...>

Envelope
++++++++

.envelope : geometry
  Returns the geometry's rectangular polygon envelope.

.. sourcecode:: python

  >>> polygon.envelope
  <shapely.geometry.polygon.Polygon object at ...>

Intersection
++++++++++++

.intersection(other) : geometry
  Returns the intersection of one geometry and the *other* geometry.

.. sourcecode:: python

  >>> polygon.intersection(hull)
  <shapely.geometry.polygon.Polygon object at ...>

Symmetric Difference
++++++++++++++++++++

.symmetric_difference(other) : geometry
  Returns a geometry combining the points in this geometry not in *other*, and
  the points in *other* not in this geometry.

.. sourcecode:: python

  >>> polygon.symmetric_difference(hull)
  <shapely.geometry.multipolygon.MultiPolygon object at ...>

Union
+++++

.union(other) : geometry
  Returns the union of one geometry and the *other* geometry.

Point unions were demonstrated above under convex hull. The union of polygons
will be a polygon or a multi-polygon depending on whether they intersect or
not:

.. sourcecode:: python

  >>> hull.union(polygon)
  <shapely.geometry.polygon.Polygon object at ...>


Other Operations
----------------

Polygonization
++++++++++++++

shapely.ops.polygonize(lines) : iterator
  Returns an iterator over polygons constructed from the *lines* iterator. The
  elements of *lines* may be Shapely geometries, objects that provide the geo
  interface, or Numpy arrays or Python sequences shaped like LineStrings.

.. sourcecode:: python

  >>> from shapely.ops import polygonize
  >>> lines = [
  ...     ((0, 0), (1, 1)),
  ...     ((0, 0), (0, 1)),
  ...     ((0, 1), (1, 1)),
  ...     ((1, 1), (1, 0)),
  ...     ((1, 0), (0, 0))
  ...     ]
  >>> result = polygonize(lines)
  >>> list(result.geoms)
  [<shapely.geometry.polygon.Polygon object at ...>, <shapely.geometry.polygon.Polygon object at ...>]

Line merging
++++++++++++

shapely.ops.linemerge(lines) : iterator or MultiLineString
  Merges all connected lines. Returns a LineString or MultiLineString when
  lines are not contiguous. 

.. sourcecode:: python

  >>> lines = MultiLineString([ 
  ...     ((0, 0), (1, 1)), 
  ...     ((2, 0), (2, 1), (1, 1)) 
  ...     ]) 
  >>> result = linemerge(lines)
  >>> result # docstring: +ELLIPSIS
  <shapely.geometry.linestring.LineString object at 0x...>


Unary Spatial Predicates
------------------------

These are implemented as Python attributes.

Is Empty
++++++++

.is_empty : bool
  True if the set of points in this geometry is empty, else False. For more
  details, see
  http://geos.refractions.net/ro/doxygen_docs/html/classgeos_1_1geom_1_1Geometry.html#a17.  

Is Valid
++++++++

.is_valid : bool
  True if the geometry is valid (definition depends on sub-class), else False.
  For more details, see
  http://geos.refractions.net/ro/doxygen_docs/html/classgeos_1_1geom_1_1Geometry.html#a16.

Is Ring
+++++++

.is_ring : bool
  True if the geometry is a closed ring, else False.

Has Z
+++++

.has_z : bool
  True if the geometry's coordinate sequence(s) have z values (are
  3-dimensional)

Examples
++++++++

.. sourcecode:: python

  >>> polygon.is_empty
  False
  >>> polygon.is_valid
  True
  >>> polygon.is_ring
  False
  >>> polygon.boundary.is_ring
  True
  >>> polygon.has_z
  False

(Note: that last return value exposes a bug in GEOS 2.2.3.)


Binary Spatial Predicates
-------------------------

All of these methods take a single positional argument, an *other* geometry. It
is important to note that these are topological and not point-wise operations,
and therefore may produce results that are not what one might expect from
operations on Python.

Contains
++++++++

.contains(other) : bool
  True if the geometry is spatially within, without touching. Applies to all
  types of geometries.

.. sourcecode:: python

  >>> polygon.contains(point_b)
  True

Crosses
+++++++

.crosses(other) : bool
  Only linear geometries (lines, rings, polygon boundaries) may ever cross. No
  geometry may ever cross a point.

.. sourcecode:: python

  >>> line_b.crosses(polygon)
  True

Disjoint
++++++++

.disjoint(other) : bool
  True if geometries do not spatially relate in any way, else False. See the
  complementary *intersects*. 

.. sourcecode:: python

  >>> polygon.disjoint(point_r)
  True

Equals
++++++

.equals(other) : bool
  Two geometries are topologically equal if their interiors intersect and no
  part of the interior or boundary of one geometry intersects the exterior of
  the other. Not to be confused with Python's *__equals__*.

Intersects
++++++++++

.intersects(other) : bool
  This predicate is the complement of *disjoint*: geometries that do not
  intersect are disjoint. Intersects is the most inclusive predicate.

.. sourcecode:: python

  >>> polygon.intersects(point_b)
  True

Touches
+++++++

.touches(other) : bool
  True if geometries *only* touch. The least inclusive predicate.

.. sourcecode:: python

  >>> polygon.touches(line_g)
  True
  >>> polygon.touches(line_b)
  False

Within
++++++

.within(other): bool
  The inverse of *contains*.


General Methods
---------------

Distance
++++++++

.distance(other) : geometry
  The minimum distance from one geometry to the other.

.. sourcecode:: python

  >>> Point(0,0).distance(Point(1,1))
  1.4142135623730951


Scalar Properties
-----------------

Area
++++

.area : float
  Area of the geometry, unitless. Non-zero only for surfaces (polygons,
  multi-polygons).

Bounds
++++++

.bounds : tuple
  The geometry's (minx, miny, maxx, maxy) bounding box.

Length
++++++

.length : float
  Length of the geometry, unitless. Non-zero only for linear geometries
  (line strings, rings, polygon boundaries)

Examples
++++++++

.. sourcecode:: python

  >>> polygon.area
  4.0
  >>> polygon.bounds
  (-1.0, -1.0, 1.0, 1.0)
  >>> polygon.length
  8.0
  >>> line_r.length
  1.0
  >>> line_b.length
  3.9812058474788765


Geometry Parts and Coordinates
==============================

Coordinate Sequences
--------------------

The coordinates of points, line strings, and polygon rings can be accessed
through the *coords* attribute of a geometry. *Coords* is an iterator over
coordinate tuples.

.. sourcecode:: python

  >>> point_r.coords
  <shapely.geometry.base.CoordinateSequence object at ...>
  >>> len(point_r.coords)
  1
  >>> point_r.coords[0]
  (-1.5, 1.2)
  >>> list(point_r.coords)
  [(-1.5, 1.2)]

The coordinate sequence can be modifed by assigning a sequence (**a**\ 1, ...,
**a**\ M) to the coords attribute.

.. sourcecode:: python

  >>> point_new = Point(0, 0)
  >>> point_new.coords = (1, 1)
  >>> list(point_new.coords)
  [(1.0, 1.0)]

For line strings:

.. sourcecode:: python

  >>> line_new = LineString([(0,0), (1,1)])
  >>> line_new.coords = [(1,1), (2,2)]
  >>> list(line_new.coords)
  [(1.0, 1.0), (2.0, 2.0)]


Polygon Rings
-------------

The exterior boundary of a polygon can be accessed through the *exterior*
attribute of the geometry object.

.. sourcecode:: python

  >>> polygon.exterior
  <shapely.geometry.polygon.LinearRing object at ...>
  >>> list(polygon.exterior.coords)
  [(-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0), (1.0, -1.0), (-1.0, -1.0)]

The interior boundaries (or holes) of a polygon can be accessed through the
*interiors* attribute, which is a list of rings.


Sub-geometries
--------------

The parts of a multi-part geometry can be accessed through the *geoms*
attribute of the geometry object, which is an iterator over the sub-geometries:

.. sourcecode:: python

  >>> multi_point.geoms
  <shapely.geometry.base.GeometrySequence object at ...>
  >>> len(multi_point.geoms)
  3
  >>> from pprint import pprint
  >>> pprint(list(multi_point.geoms))
  [<shapely.geometry.point.Point object at ...>,
   <shapely.geometry.point.Point object at ...>,
   <shapely.geometry.point.Point object at ...>]

The coordinate sequences of these sub-geometries can then be accessed as
described above.


Point Coordinates
-----------------

For the sake of convenience the coordinate values of points can be accessed
read-only via **x**, **y**, and **z** attributes:

.. sourcecode:: python

  >>> point = Point(1.0, 1.0)
  >>> point.x
  1.0
  >>> point.y
  1.0


Interoperation
==============

Shapely provides 4 avenues for interoperation with other Python and GIS
software.

Well-known Formats
------------------

Well-known Text (WKT)
+++++++++++++++++++++

The WKT representation of any geometry object can be had via the **wkt**
attribute:

.. sourcecode:: python

  >>> point_r.wkt
  'POINT (-1.5000000000000000 1.2000000000000000)'

Hex-encode that string and you have a value that can be conveniently inserted directly into PostGIS

.. sourcecode:: python

  >>> point_r.wkt.encode('hex')
  '504f494e5420282d312e3530303030303030303030303030303020312e3230303030303030303030303030303029'

New geometries can be created from WKT representations using the
*shapely.wkt.loads* factory (inspired by the *pickle* module) 

.. sourcecode:: python

  >>> from shapely.wkt import loads
  >>> loads('POINT (0 0)')
  <shapely.geometry.point.Point object at ...>

Well-known Binary (WKB)
+++++++++++++++++++++++

The WKB representation of any geometry object can be had via the **wkb**
attribute. New geometries can be created from WKB data using the
*shapely.wkb.loads* factory. Use this format to interoperate with ogr.py:

.. sourcecode:: python

  >>> import ogr
  >>> from shapely.wkb import loads
  >>> source = ogr.Open("/tmp/world_borders.shp")
  >>> borders = source.GetLayerByName("world_borders")
  >>> feature = borders.GetNextFeature()
  >>> loads(feature.GetGeometryRef().ExportToWkb())
  <shapely.geometry.polygon.Polygon object at ...>


Python Sequences
----------------

Python sequence data can be analyzed as Shapely geometries using the
*shapely.geometry.as\** adapters while leaving the data in its original
storage. A pair of float can be treated as a point with **asPoint**:

.. sourcecode:: python

  >>> from shapely.geometry import asPoint
  >>> coords = [3.0, 4.0]
  >>> pa = asPoint(coords)
  >>> pa.wkt
  'POINT (3.0000000000000000 4.0000000000000000)'

Move the coordinates and watch the geometry adapter change

.. sourcecode:: python

  >>> coords[0] = 1.0
  >>> pa.wkt
  'POINT (1.0000000000000000 4.0000000000000000)'

The **asLineString** adapter works much the same. The **asPolygon** adapter is
used like

.. sourcecode:: python

  >>> from shapely.geometry import asPolygon
  >>> coords = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0]]
  >>> hole_coords = [((0.1,0.1), (0.1,0.2), (0.2,0.2), (0.2,0.1))]
  >>> pa = asPolygon(coords, hole_coords)
  >>> len(pa.exterior.coords)
  5
  >>> len(pa.interiors)
  1
  >>> len(pa.interiors[0].coords)
  5


Numpy Array Interface
---------------------

Shapely geometries provide the Numpy array interface which means that points,
line strings, and polygon rings can be used as Numpy arrays:

.. sourcecode:: python

  >>> from numpy import array
  >>> a = array(polygon.exterior)
  >>> a
  array([[-1., -1.],
         [-1.,  1.],
         [ 1.,  1.],
         [ 1., -1.],
         [-1., -1.]])

The *numpy.asarray* function does not copy coordinate values at the price of
slower numpy access to coordinates.

The *shapely.geometry.as\** functions can also be used to wrap numpy arrays,
which can then be analyzed using Shapely while maintaining their original
storage. A 1 x 2 array can be adapted to a point

.. sourcecode:: python

  >>> a = array([1.0, 2.0])
  >>> pa = asPoint(a)
  >>> pa.wkt
  'POINT (1.0000000000000000 2.0000000000000000)'

and a N x 2 array can be adapted to a line string

.. sourcecode:: python

  >>> from shapely.geometry import asLineString
  >>> a = array([[1.0, 2.0], [3.0, 4.0]])
  >>> la = asLineString(a)
  >>> la.wkt
  'LINESTRING (1.0000000000000000 2.0000000000000000, 3.0000000000000000 4.0000000000000000)'

There is no Numpy array representation of a polygon.


Python Geo Interface
--------------------

Any object that provides the GeoJSON-like `Python geo interface`_ can be
adapted and used as a Shapely geometry using the *shapely.geometry.asShape*
function. For example, a dictionary:

.. sourcecode:: python

  >>> from shapely.geometry import asShape
  >>> d = {"type": "Point", "coordinates": (0.0, 0.0)}
  >>> shape = asShape(d)
  >>> shape.geom_type
  'Point'
  >>> list(shape.coords)
  [(0.0, 0.0)]

Or a simple placemark-type object:

.. sourcecode:: python

  >>> class GeoThing(object):
  ...     def __init__(self, d):
  ...         self.__geo_interface__ = d
  >>> thing = GeoThing({"type": "Point", "coordinates": (0.0, 0.0)})
  >>> shape = asShape(thing)
  >>> shape.geom_type
  'Point'
  >>> list(shape.coords)
  [(0.0, 0.0)]

If you want to copy coordinate data to a new geometry, use the
*shapely.geometry.shape* function instead.

.. _Python geo interface: http://trac.gispython.org/projects/PCL/wiki/PythonGeoInterface


Advanced Features
=================

Iterative Operations
--------------------

Shapely provides functions for efficient operations on large sets of
geometries.

Contains
++++++++

To find the subset of points that are contained within a polygon, use
*shapely.iterops.contains*:

.. sourcecode:: python

  >>> from shapely.geometry import Polygon
  >>> from shapely.geometry import Point
  >>> coords = ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0))
  >>> polygon = Polygon(coords)
  >>> points = [Point(0.5, 0.5), Point(2.0, 2.0)]  
  >>> from shapely import iterops  
  >>> list(iterops.contains(polygon, points, True))
  [<shapely.geometry.point.Point object at ...>]

The second parameter to *iterops.contains* can be any kind of iterator, even a
generator of objects. If it yields tuples, then the second element of the tuple
will be ultimately yielded from *iterops.contains*.

.. sourcecode:: python

  >>> list(iterops.contains(polygon, iter((p, p.wkt) for p in points)))
  ['POINT (0.5000000000000000 0.5000000000000000)']

Prepared Geometry Operations
----------------------------

Shapely geometries can be pre-analyzed into a state that supports more
efficient batches of operations. To test one polygon containment against a
large batch of points, one should first use the `prepared.prep` function:

.. sourcecode:: python

  >>> from shapely.geometry import Point
  >>> from shapely.prepared import polyprep
  >>> points = [...] # large list of points
  >>> polygon = Point(0.0, 0.0).buffer(1.0)
  >>> prepared_polygon = prep(polygon)
  >>> prepared_polygon
  <shapely.prepared.PreparedGeometry object at ...>
  >>> hits = filter(prepared_polygon.contains, points)

Prepared geometries instances have the following methods: ``contains``,
``contains_properly``, ``covers``, and ``intersects``. All have exactly the
same arguments and usage as their counterparts in the standard geometries.

Credits
=======

Shapely is written by Sean Gillies with contributions from Aron Bierbaum,
Howard Butler, Kai Lautaportti (Hexagon IT), Frédéric Junod (Camptocamp SA),
Eric Lemoine (Camptocamp SA) and ctypes tips from Justin Bronn (GeoDjango).

.. _GEOS: http://geos.refractions.net
.. _Java Topology Suite: http://www.vividsolutions.com/jts/jtshome.htm
.. _PostGIS: http://postgis.refractions.net
.. _record: http://pypi.python.org/pypi/Shapely
.. _wiki: http://trac.gispython.org/lab/wiki/Shapely

